// mainloop.c

#include <common.h>
#include <adc.h>
#include <interface.h>
#include <maintimer.h>
#include <config.h>
#include <properties.h>
#include <arraysize.h>
#include <math.h>
#include <temperature.h>


void estimator_update(uint8_t curtime);


void mainLoop(void)
{
	uint16_t data ps_raw = 0;
	uint16_t data pd_raw = 0;
	uint8_t time = 0;

	for (;;)
	{
		uint8_t curtime = mainTimer_getTime();

		if (adc_get(&ps_raw, &pd_raw))				// new ADC readings ?
		{
			const float KPS = config.kps / config.kref / 65536.0f;
			const float KPD = config.kpd / config.kref / 65536.0f;

			const float alpha_ps = 0.01f;
			const float alpha_pd = 0.01f;

			properties.ps = properties.ps * (1 - config.lpf_alpha)
				 + (((ps_raw * KPS + 0.095f) / 0.009f) * 1000.0f) * config.lpf_alpha;
			properties.pd = properties.pd * (1 - config.lpf_alpha)
				 + (5000.0f * pd_raw * KPD - 1000.0f) * config.lpf_alpha;

			#define b (-0.0065f)
			#define R (287.058f)
			#define g (9.80665f)
			#define r0 (1.225f)

			properties.alt_raw = config.temp0 / b * (pow(properties.ps / config.ps0, -R * b / g) - 1);
			estimator_update(curtime);

			properties.ias = (properties.pd > config.pd0) ? sqrt(2 * (properties.pd - config.pd0) / r0) : 0;
			properties.tas = properties.ias * sqrt(r0 * R * properties.temp / properties.ps);
		}

		if (time != curtime)
		{
			time = curtime;
			interface_update();
			config_checkModified();
			temperature_update();
		}
	}
}


/////////////////////////////////////////////////////////////////


static void estimator_update(uint8_t curtime)
{
	static uint8_t time = 0;
	const float var_h = config.var_h;
	const float var_a = config.var_a;
	static float p_hh = 1.e10;
	static float p_hv = 0;
	static float p_vv = 0;

	float delta, s_inv, k_h, k_v;

	const float dt = ((uint8_t)(curtime - time)) * 0.001f;
	time = curtime;

	// Predict step.
	// Update state estimate.
	properties.alt += properties.vspeed * dt;

	// Update state covariance. The last term mixes in acceleration noise.
	p_hh += 2.0f * dt * p_hv + dt * dt * p_vv + var_a * dt * dt * dt * dt / 4.0f;
	p_hv +=                         dt * p_vv + var_a * dt * dt * dt / 2.0f;
	p_vv +=                                   + var_a * dt * dt;

	// Update step.
	delta = properties.alt_raw - properties.alt;  // Innovation.
	s_inv = 1.0f / (p_hh + var_h);  // Innovation precision.
	k_h = p_hh * s_inv;  // Kalman gain
	k_v = p_hv * s_inv;

	// Update state estimate.
	properties.alt += k_h * delta;
	properties.vspeed += k_v * delta;

	// Update state covariance.
    p_vv -= p_hv * k_v;
	p_hv -= p_hv * k_h;
	p_hh -= p_hh * k_h;
}





